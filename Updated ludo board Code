`timescale 1ns / 1ps

//============================================================
// TOP MODULE
//============================================================
module LudoBoard_Top (
    input clk,
    input rst_n,

    input roll_btn_raw,
    input select_btn_raw,
    input confirm_btn_raw,

    input [26:0] sensors_raw,

    output [2:0] dice_value,
    output dice_rolled,
    output current_player,
    output selected_piece,
    output [4:0] target_pos,
    output move_error,
    output waiting_for_roll,
    output waiting_for_place,
    output winner_red,
    output winner_blue,
    output [7:0] debug_leds,
    output [6:0] seg,
    output [3:0] an
);

    wire rst = ~rst_n;

    wire roll_clean, sel_clean, conf_clean;
    wire roll_pulse, sel_pulse, conf_pulse;
    wire [26:0] sensors_sync;

    // Debounce buttons
    debounce db1(clk, rst, roll_btn_raw, roll_clean);
    debounce db2(clk, rst, select_btn_raw, sel_clean);
    debounce db3(clk, rst, confirm_btn_raw, conf_clean);

    // Edge detection
    edge_det e1(clk, rst, roll_clean, roll_pulse);
    edge_det e2(clk, rst, sel_clean, sel_pulse);
    edge_det e3(clk, rst, conf_clean, conf_pulse);

    // Synchronize sensors
    synchronizer sync1(clk, rst, sensors_raw, sensors_sync);

    // Game Controller
    game_controller GAME (
        clk, rst,
        roll_pulse, sel_pulse, conf_pulse,
        sensors_sync,

        dice_value,
        dice_rolled,
        current_player,
        selected_piece,
        target_pos,
        move_error,
        waiting_for_roll,
        waiting_for_place,
        winner_red,
        winner_blue,
        debug_leds
    );

    // Display Controller
    display_controller DISP (
        clk, rst,
        dice_value,
        current_player,
        winner_red,
        winner_blue,
        seg, an
    );

endmodule

//============================================================
// DEBOUNCE
//============================================================
module debounce(input clk, input rst, input btn, output reg out);
    reg [19:0] cnt;
    reg sync1, sync2;

    always @(posedge clk) begin
        sync1 <= btn;
        sync2 <= sync1;
    end

    always @(posedge clk) begin
        if (rst) begin
            cnt <= 0;
            out <= 0;
        end else if (sync2 != out) begin
            cnt <= cnt + 1;
            if (cnt == 20'd1_000_000) begin
                out <= sync2;
                cnt <= 0;
            end
        end else cnt <= 0;
    end
endmodule

//============================================================
// EDGE DETECTOR
//============================================================
module edge_det(input clk, input rst, input sig, output pulse);
    reg d;
    always @(posedge clk) begin
        if (rst) d <= 0;
        else d <= sig;
    end
    assign pulse = sig & ~d;
endmodule

//============================================================
// SYNCHRONIZER
//============================================================
module synchronizer(input clk, input rst,
                    input [26:0] a,
                    output reg [26:0] y);
    reg [26:0] d;
    always @(posedge clk) begin
        if (rst) begin d <= 0; y <= 0; end
        else begin d <= a; y <= d; end
    end
endmodule

//============================================================
// DICE ROLLER
//============================================================
module dice_roller(input clk, input rst, input roll,
                   output reg [2:0] dice, output reg done);

    reg [15:0] lfsr;
    reg rolling;
    reg [4:0] cnt;

    wire fb = lfsr[15]^lfsr[13]^lfsr[12]^lfsr[10];

    always @(posedge clk) begin
        if (rst) begin
            lfsr <= 16'hACE1;
            dice <= 3'd1;
            rolling <= 0;
            done <= 0;
        end else begin
            lfsr <= {lfsr[14:0], fb};
            done <= 0;

            if (roll && !rolling) begin
                rolling <= 1;
                cnt <= 5'd20;
            end

            if (rolling) begin
                dice <= (lfsr[2:0] % 6) + 1;
                cnt <= cnt - 1;
                if (cnt == 0) begin
                    rolling <= 0;
                    done <= 1;
                end
            end
        end
    end
endmodule

//============================================================
// GAME CONTROLLER
//============================================================
module game_controller(
    input clk, input rst,
    input roll_p, input sel_p, input conf_p,
    input [26:0] sensors,

    output reg [2:0] dice_value,
    output reg dice_rolled,
    output reg current_player,
    output reg selected_piece,
    output reg [4:0] target_pos,
    output reg move_error,
    output reg waiting_for_roll,
    output reg waiting_for_place,
    output reg winner_red,
    output reg winner_blue,
    output reg [7:0] debug_leds
);

    // STATES
    localparam IDLE=0, ROLL=1, SELECT=2, PLACE=3, UPDATE=4, NEXT=5;

    reg [2:0] state;
    reg [4:0] pos [0:3];   // 0,1 red | 2,3 blue
    reg [5:0] steps [0:3];
    wire [1:0] idx = {current_player, selected_piece};

    wire dice_done;
    wire [2:0] dice_out;

    dice_roller D(clk, rst, roll_p, dice_out, dice_done);

    integer i;

    always @(posedge clk) begin
        if (rst) begin
            state <= IDLE;
            current_player <= 0;
            selected_piece <= 0;
            dice_value <= 1;
            dice_rolled <= 0;
            waiting_for_roll <= 1;
            waiting_for_place <= 0;
            move_error <= 0;
            winner_red <= 0;
            winner_blue <= 0;
            for (i=0;i<4;i=i+1) begin
                pos[i] <= 31;   // all pieces start at home
                steps[i] <= 0;
            end
        end else begin
            dice_rolled <= 0;
            move_error <= 0;

            case (state)
                IDLE: begin
                    waiting_for_roll <= 1;
                    if (roll_p) state <= ROLL;
                end

                ROLL: begin
                    waiting_for_roll <= 0;
                    if (dice_done) begin
                        dice_value <= dice_out;
                        dice_rolled <= 1;
                        state <= SELECT;
                    end
                end

                SELECT: begin
                    if (sel_p) selected_piece <= ~selected_piece;
                    if (conf_p) state <= PLACE;
                end

                PLACE: begin
                    waiting_for_place <= 1;

                    // Determine target position
                    if (pos[idx] == 31) begin
                        target_pos <= current_player ? 8 : 0; // entering from home
                    end else begin
                        target_pos <= pos[idx] + dice_value;
                    end

                    if (conf_p) begin
                        // Check if move is legal using sensors
                        if (sensors[target_pos]) state <= UPDATE;
                        else move_error <= 1;
                    end
                end

                UPDATE: begin
                    waiting_for_place <= 0;

                    // --- Capture Logic (Manual for 4 pieces) ---
                    // If current player is Red (0), capture Blue (2,3)
                    if (current_player == 0) begin
                        if (pos[2] == target_pos) begin pos[2] <= 31; steps[2] <= 0; end
                        if (pos[3] == target_pos) begin pos[3] <= 31; steps[3] <= 0; end
                    end
                    // If current player is Blue (1), capture Red (0,1)
                    else begin
                        if (pos[0] == target_pos) begin pos[0] <= 31; steps[0] <= 0; end
                        if (pos[1] == target_pos) begin pos[1] <= 31; steps[1] <= 0; end
                    end

                    // Move current piece
                    pos[idx] <= target_pos;
                    steps[idx] <= steps[idx] + dice_value;

                    state <= NEXT;
                end

                NEXT: begin
                    // Winner detection
                    if (pos[0]==26 && pos[1]==26) winner_red <= 1;
                    if (pos[2]==26 && pos[3]==26) winner_blue <= 1;

                    // Turn switching
                    if (dice_value != 6) current_player <= ~current_player;
                    selected_piece <= 0;
                    state <= IDLE;
                end
            endcase

            debug_leds <= {state, current_player, selected_piece};
        end
    end
endmodule

//============================================================
// DISPLAY CONTROLLER
//============================================================
module display_controller(
    input clk,
    input rst,
    input [2:0] dice,
    input player,           // 0=Red, 1=Blue
    input win_r, win_b, 
    output reg [6:0] seg,
    output reg [3:0] an
);

    reg [19:0] refresh_counter;
    wire refresh_clk = refresh_counter[18];
    reg digit_sel; // 0=dice, 1=player
    reg [3:0] value;

    always @(posedge clk or posedge rst) begin
        if(rst) refresh_counter <= 0;
        else refresh_counter <= refresh_counter + 1;
    end

    always @(posedge refresh_clk or posedge rst) begin
        if(rst) digit_sel <= 0;
        else digit_sel <= ~digit_sel;
    end

    always @(*) begin
        if(digit_sel) begin
            an = 4'b1000; // leftmost
            if(win_r) value = 4'd10; // "R" winner
            else if(win_b) value = 4'd11; // "B" winner
            else value = player ? 4'd11 : 4'd10; // current player
        end else begin
            an = 4'b0001; // rightmost
            if(win_r) value = 4'd10;
            else if(win_b) value = 4'd11;
            else value = dice; // dice value
        end

        case(value)
            4'd0: seg = 7'b1000000;
            4'd1: seg = 7'b1111001;
            4'd2: seg = 7'b0100100;
            4'd3: seg = 7'b0110000;
            4'd4: seg = 7'b0011001;
            4'd5: seg = 7'b0010010;
            4'd6: seg = 7'b0000010;
            4'd7: seg = 7'b1111000;
            4'd8: seg = 7'b0000000;
            4'd9: seg = 7'b0010000;
            4'd10: seg = 7'b0001001; // "R"
            4'd11: seg = 7'b1000110; // "B"
            default: seg = 7'b1111111;
        endcase
    end
endmodule


